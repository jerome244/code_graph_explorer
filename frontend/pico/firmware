/*
  Pico W — LED · RFID · Relay (non-blocking pulse) · Thermistor (HTTP API)

  Endpoints (GET):
    /api/status                    -> {state:"off|on|blinking"}               // LED status
    /api/led?state=on|off          -> {state:"on|off"}                        // LED control
    /api/blink?hz=1..20            -> {state:"blinking"}                      // LED blink

    /api/rfid/last                 -> {uid,at_ms,age_ms}
    /api/rfid/scan                 -> {uid,at_ms,age_ms}
    /api/rfid/clear                -> {ok:true}
    /api/rfid/debug                -> {version_reg:"0x.."}

    /api/relay/status              -> {state:"on|off"}
    /api/relay?state=on|off        -> {state:"on|off"}
    /api/relay/pulse?ms=10..10000  -> {state:"pulsing",ms:N}   // non-blocking

    /api/thermistor/read           -> {raw,raw_bits,voltage,resistance_ohm,temp_c,ntc_to_3v3}

  Pins (default):
    LED_BUILTIN                      — onboard LED
    RELAY_PIN         GP15           — drives NPN base via ~1k (low-side)
      Coil: +3.3V -> relay coil -> NPN collector; NPN emitter -> GND
      Flyback diode across coil: stripe/cathode to +3.3V, anode to collector

    RC522 on SPI0:
      SS/SDA  -> GP17
      SCK     -> GP18
      MOSI    -> GP19
      MISO    -> GP16
      RST     -> GP22
      3.3V/GND to module power

    Thermistor (NTC 10k, B=3950), voltage divider (orientation selectable):
      If NTC_TO_3V3 = 1: 3V3 -> NTC -> node -> 10k -> GND (node -> GP26/ADC0)
      If NTC_TO_3V3 = 0: 3V3 -> 10k -> node -> NTC -> GND (node -> GP26/ADC0)

  Notes:
    - Non-blocking relay pulse keeps HTTP server responsive.
    - CORS, Connection: close, Cache-Control: no-store set on all responses.
*/

#include <WiFi.h>
#include <WebServer.h>
#include <SPI.h>
#include <MFRC522.h>
#include <math.h>

// ================= WIFI =================
const char* SSID     = "";
const char* PASSWORD = "";

// ================= LED ==================
enum LedMode { MODE_OFF, MODE_ON, MODE_BLINK };
volatile LedMode currentMode = MODE_OFF;
volatile uint32_t blinkIntervalMs = 500;  // toggle interval (ms)
unsigned long lastToggle = 0;
bool ledLevel = false;

// ================ RELAY =================
#define RELAY_PIN 15           // GP15 -> base via ~1k -> NPN -> coil->+3.3V
volatile bool relayOn = false;
volatile bool relayPulseActive = false;
unsigned long relayPulseUntil = 0;

// ================ RFID (RC522 on SPI0) ================
#define RFID_SS_PIN   17
#define RFID_RST_PIN  22
MFRC522 mfrc522(RFID_SS_PIN, RFID_RST_PIN);
String lastUID = "";
unsigned long lastSeenMs = 0;

// ================ THERMISTOR (NTC 10k) =================
// Divider orientation toggle:
//   1 => 3V3 -> NTC -> node -> 10k -> GND
//   0 => 3V3 -> 10k -> node -> NTC -> GND
#define NTC_TO_3V3 0   // <<< set to 0 for your wiring (warm -> Vnode goes DOWN)

#define THERM_ADC_PIN          26   // GP26 = ADC0
const float VREF               = 3.3f;           // ADC reference (typ.)
const float FIXED_RESISTOR     = 10000.0f;       // the fixed 10k
const float THERMISTOR_R0      = 10000.0f;       // 10k @ 25°C
const float THERMISTOR_BETA    = 3950.0f;        // Beta value
const float T0_K               = 273.15f + 25.0f; // 298.15 K

// ================= HTTP SERVER =================
WebServer server(80);

// ----------------- Helpers -----------------
void enableCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET, OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
  server.sendHeader("Connection", "close");
  server.sendHeader("Cache-Control", "no-store");
}

String uidToString(MFRC522::Uid *uid) {
  String s;
  for (byte i = 0; i < uid->size; i++) {
    if (i) s += ":";
    if (uid->uidByte[i] < 0x10) s += "0";
    s += String(uid->uidByte[i], HEX);
  }
  s.toUpperCase();
  return s;
}

void setRelay(bool on) {
  relayOn = on;
  digitalWrite(RELAY_PIN, on ? HIGH : LOW);
}

// ----------------- RFID init & polling -----------------
void RFID_Init() {
  pinMode(RFID_SS_PIN, OUTPUT);
  digitalWrite(RFID_SS_PIN, HIGH); // deselect RC522 before init

  // Explicit SPI0 pin mapping
  SPI.setSCK(18);
  SPI.setTX(19);
  SPI.setRX(16);
  SPI.begin();

  mfrc522.PCD_Init();   // uses pins from constructor
  delay(50);
  mfrc522.PCD_AntennaOn();

  byte ver = mfrc522.PCD_ReadRegister(mfrc522.VersionReg);
  Serial.print("RC522 VersionReg: 0x");
  Serial.println(ver, HEX);
}

void RFID_BackgroundPoll() {
  if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial()) {
    lastUID   = uidToString(&mfrc522.uid);
    lastSeenMs = millis();
    mfrc522.PICC_HaltA();
    mfrc522.PCD_StopCrypto1();
  }
}

// ----------------- Thermistor helpers -----------------
int adcReadAveraged(int pin, int samples = 8) {
  long acc = 0;
  for (int i = 0; i < samples; i++) { acc += analogRead(pin); delay(2); }
  return (int)(acc / samples);
}

// Convert divider node voltage -> NTC resistance (ohms),
// honoring the divider orientation.
float computeRT_fromV(float v) {
  // clamp to avoid div by zero / infinity
  if (v < 0.001f) v = 0.001f;
  if (v > (VREF - 0.001f)) v = VREF - 0.001f;

#if NTC_TO_3V3
  // 3V3 -> NTC -> node -> 10k -> GND
  // v = VREF * Rfixed / (Rntc + Rfixed)  ⇒  Rntc = Rfixed * (VREF / v - 1)
  return FIXED_RESISTOR * (VREF / v - 1.0f);
#else
  // 3V3 -> 10k -> node -> NTC -> GND
  // v = VREF * Rntc / (Rfixed + Rntc)    ⇒  Rntc = Rfixed * v / (VREF - v)
  return FIXED_RESISTOR * (v / (VREF - v));
#endif
}

// raw: 0..4095 (12-bit). Returns degC using Beta equation.
float thermistorCelsiusFromRaw(int raw, int maxAdc = 4095) {
  float v = (float)raw * (VREF / (float)maxAdc);  // node voltage
  float rt = computeRT_fromV(v);
  if (rt < 1.0f) rt = 1.0f;
  float invT = (1.0f / T0_K) + (logf(rt / THERMISTOR_R0) / THERMISTOR_BETA);
  float tK = 1.0f / invT;
  return tK - 273.15f;
}

// ----------------- HTTP Handlers: LED -----------------
void handleStatus() {
  enableCORS();
  const char* state = "unknown";
  switch (currentMode) {
    case MODE_OFF:  state = "off"; break;
    case MODE_ON:   state = "on"; break;
    case MODE_BLINK:state = "blinking"; break;
  }
  server.send(200, "application/json", String("{\"state\":\"") + state + "\"}");
}

void handleLed() {
  enableCORS();
  String st = server.arg("state");
  st.toLowerCase();
  if (st == "on") {
    currentMode = MODE_ON;
    digitalWrite(LED_BUILTIN, HIGH);
    ledLevel = true;
    server.send(200, "application/json", "{\"state\":\"on\"}");
  } else if (st == "off") {
    currentMode = MODE_OFF;
    digitalWrite(LED_BUILTIN, LOW);
    ledLevel = false;
    server.send(200, "application/json", "{\"state\":\"off\"}");
  } else {
    server.send(400, "application/json", "{\"error\":\"state must be on|off\"}");
  }
}

void handleBlink() {
  enableCORS();
  int hz = server.hasArg("hz") ? server.arg("hz").toInt() : 2;
  if (hz < 1) hz = 1;
  if (hz > 20) hz = 20;
  blinkIntervalMs = (uint32_t)(500.0 / (double)hz); // toggle period
  currentMode = MODE_BLINK;
  server.send(200, "application/json", "{\"state\":\"blinking\"}");
}

// ----------------- HTTP Handlers: RFID -----------------
void handleRfidLast() {
  enableCORS();
  unsigned long age = lastUID.length() ? (millis() - lastSeenMs) : 0;
  String json = "{\"uid\":";
  json += lastUID.length() ? ("\"" + lastUID + "\"") : String("null");
  json += ",\"at_ms\":" + String(lastSeenMs);
  json += ",\"age_ms\":" + String(age);
  json += "}";
  server.send(200, "application/json", json);
}

void handleRfidClear() {
  enableCORS();
  lastUID = "";
  lastSeenMs = 0;
  server.send(200, "application/json", "{\"ok\":true}");
}

void handleRfidScan() {
  enableCORS();
  unsigned long until = millis() + 300;
  bool found = false;

  while (millis() < until) {
    if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial()) {
      lastUID = uidToString(&mfrc522.uid);
      lastSeenMs = millis();
      found = true;
      mfrc522.PICC_HaltA();
      mfrc522.PCD_StopCrypto1();
      break;
    }
    delay(5);
  }

  String json = "{\"uid\":";
  json += found ? ("\"" + lastUID + "\"") : String("null");
  json += ",\"at_ms\":" + String(lastSeenMs);
  json += ",\"age_ms\":" + String(found ? 0 : (lastUID.length() ? millis() - lastSeenMs : 0));
  json += "}";
  server.send(200, "application/json", json);
}

void handleRfidDebug() {
  enableCORS();
  byte ver = mfrc522.PCD_ReadRegister(mfrc522.VersionReg);
  String json = String("{\"version_reg\":\"0x") + String(ver, HEX) + "\"}";
  server.send(200, "application/json", json);
}

// ----------------- HTTP Handlers: RELAY -----------------
void handleRelayStatus() {
  enableCORS();
  server.send(200, "application/json",
              String("{\"state\":\"") + (relayOn ? "on" : "off") + "\"}");
}

void handleRelay() {
  enableCORS();
  String st = server.arg("state");
  st.toLowerCase();
  if (st == "on") {
    setRelay(true);
    server.send(200, "application/json", "{\"state\":\"on\"}");
  } else if (st == "off") {
    setRelay(false);
    relayPulseActive = false; // cancel any pending pulse
    server.send(200, "application/json", "{\"state\":\"off\"}");
  } else {
    server.send(400, "application/json", "{\"error\":\"state must be on|off\"}");
  }
}

// Non-blocking pulse: reply immediately, finish in loop()
void handleRelayPulse() {
  enableCORS();
  int ms = server.hasArg("ms") ? server.arg("ms").toInt() : 200;
  if (ms < 10) ms = 10;
  if (ms > 10000) ms = 10000;

  setRelay(true);
  relayPulseActive = true;
  relayPulseUntil = millis() + (unsigned long)ms;

  String json = String("{\"state\":\"pulsing\",\"ms\":") + String(ms) + "}";
  server.send(200, "application/json", json);
}

// ----------------- HTTP Handlers: THERMISTOR -----------
void handleThermistorRead() {
  enableCORS();

  const int MAXADC = 4095;  // 12-bit

  int raw = adcReadAveraged(THERM_ADC_PIN, 10);
  float v  = (float)raw * (VREF / (float)MAXADC);
  float rt = computeRT_fromV(v);
  if (rt < 1.0f) rt = 1.0f;
  float tc = thermistorCelsiusFromRaw(raw, MAXADC);

  String json = "{";
  json += "\"raw\":" + String(raw);
  json += ",\"raw_bits\":12";
  json += ",\"voltage\":" + String(v, 4);
  json += ",\"resistance_ohm\":" + String(rt, 1);
  json += ",\"temp_c\":" + String(tc, 2);
  json += ",\"ntc_to_3v3\":" + String((int)NTC_TO_3V3);
  json += "}";
  server.send(200, "application/json", json);
}

// ----------------- Misc -----------------
void handleOptions() { enableCORS(); server.send(204); }
void handleNotFound() { enableCORS(); server.send(404, "text/plain", "Not found"); }

// ================== SETUP ==================
void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);

  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, LOW);

  // ADC setup
  analogReadResolution(12);       // 0..4095
  pinMode(THERM_ADC_PIN, INPUT);

  Serial.begin(115200);
  delay(500);
  Serial.println("Booting...");

  // WiFi
  WiFi.mode(WIFI_STA);
  WiFi.begin(SSID, PASSWORD);
  Serial.print("Connecting");
  while (WiFi.status() != WL_CONNECTED) { delay(400); Serial.print("."); }
  Serial.println();
  Serial.print("IP: "); Serial.println(WiFi.localIP());

  // RFID
  RFID_Init();

  // Routes
  server.on("/api/status",          HTTP_GET, handleStatus);
  server.on("/api/led",             HTTP_GET, handleLed);
  server.on("/api/blink",           HTTP_GET, handleBlink);

  server.on("/api/rfid/last",       HTTP_GET, handleRfidLast);
  server.on("/api/rfid/clear",      HTTP_GET, handleRfidClear);
  server.on("/api/rfid/scan",       HTTP_GET, handleRfidScan);
  server.on("/api/rfid/debug",      HTTP_GET, handleRfidDebug);

  server.on("/api/relay/status",    HTTP_GET, handleRelayStatus);
  server.on("/api/relay",           HTTP_GET, handleRelay);
  server.on("/api/relay/pulse",     HTTP_GET, handleRelayPulse);

  server.on("/api/thermistor/read", HTTP_GET, handleThermistorRead);

  // CORS preflight
  server.on("/",                    HTTP_OPTIONS, handleOptions);
  server.on("/api/status",          HTTP_OPTIONS, handleOptions);
  server.on("/api/led",             HTTP_OPTIONS, handleOptions);
  server.on("/api/blink",           HTTP_OPTIONS, handleOptions);
  server.on("/api/rfid/last",       HTTP_OPTIONS, handleOptions);
  server.on("/api/rfid/clear",      HTTP_OPTIONS, handleOptions);
  server.on("/api/rfid/scan",       HTTP_OPTIONS, handleOptions);
  server.on("/api/rfid/debug",      HTTP_OPTIONS, handleOptions);
  server.on("/api/relay/status",    HTTP_OPTIONS, handleOptions);
  server.on("/api/relay",           HTTP_OPTIONS, handleOptions);
  server.on("/api/relay/pulse",     HTTP_OPTIONS, handleOptions);
  server.on("/api/thermistor/read", HTTP_OPTIONS, handleOptions);

  server.onNotFound(handleNotFound);
  server.begin();
  Serial.println("HTTP server started");
}

// ================== LOOP ===================
void loop() {
  server.handleClient();

  // LED blink
  if (currentMode == MODE_BLINK) {
    unsigned long now = millis();
    if (now - lastToggle >= blinkIntervalMs) {
      ledLevel = !ledLevel;
      digitalWrite(LED_BUILTIN, ledLevel ? HIGH : LOW);
      lastToggle = now;
    }
  }

  // RFID background update
  RFID_BackgroundPoll();

  // Finish non-blocking relay pulse
  if (relayPulseActive && (long)(millis() - relayPulseUntil) >= 0) {
    setRelay(false);
    relayPulseActive = false;
  }
}
